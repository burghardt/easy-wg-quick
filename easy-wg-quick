#!/bin/sh
# easy-wg-quick - Creates Wireguard configuration for hub and peers with ease
# Copyright (C) 2019 Krzysztof Burghardt <krzysztof@burghardt.pl>
#
#
# License
# -------
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
# You are encouraged to send comments, improvements or suggestions to
# me at krzysztof@burghardt.pl
#
# For updates visit https://github.com/burghardt/easy-wg-quick

check_if_wg_is_installed() {
    wg show interfaces >/dev/null 2>&1 || {
        echo 'Unable to use "wg" command. Are wireguard tools installed?'
        printf 'Read https://github.com/burghardt/easy-wg-quick#prerequisites\n'
        exit 1
    }
}

detect_ext_net_if() {
    if test "x$(uname -s)" = "xFreeBSD"; then
        route get default | awk '$1 == "interface:" { print $2 }'
    elif test "x$(uname -s)" = "xLinux"; then
        ip route sh | awk '$1 == "default" { print $5 }'
    fi
}

create_ext_net_if() {
    echo "No extnetif.txt... creating one!"
    detect_ext_net_if > extnetif.txt
    test -s extnetif.txt || {
        echo 'Unable to detect external interface name.'
        echo 'Set it manually in extnetif.txt file and star script again.'
        exit 1
    }
}

get_ext_net_if() {
    cat extnetif.txt
}

detect_ext_net_ip() {
    if test "x$(uname -s)" = "xFreeBSD"; then
        ifconfig "$1" | awk '$1 == "inet" { print $2 }'
    elif test "x$(uname -s)" = "xLinux"; then
        ip addr sh "$1" | grep 'inet ' | xargs | awk -F'[ /]' '{ print $2 }'
    fi
}

create_ext_net_ip() {
    echo "No extnetip.txt... creating one!"
    detect_ext_net_ip "$1" > extnetip.txt
    test -s extnetip.txt || {
        echo 'Unable to detect external interface IP address.'
        echo 'Set it manually in extnetip.txt file and star script again.'
        exit 1
    }
}

get_ext_net_ip() {
    cat extnetip.txt
}

detect_fw_type() {
    if test "x$(uname -s)" = "xFreeBSD"; then
        echo "pf"
    elif test "x$(uname -s)" = "xLinux"; then
        echo "iptables"
    fi
}

create_fw_type() {
    echo "No fwtype.txt... creating one!"
    detect_fw_type > fwtype.txt
    test -s fwtype.txt || {
        echo 'Unable to detect firewall type.'
        echo 'Set it manually in fwtype.txt file and star script again.'
        exit 1
    }
}

get_fw_type() {
    cat fwtype.txt
}

check_if_ipv6_is_available() {
    if test "x$(uname -s)" = "xFreeBSD"; then
        IPV6ADR=$(ifconfig "$1" | awk '$1 == "inet6" { print $2 }' | grep -v "%$1$")
        test -n "$IPV6ADR" && {
            echo 'Looks like you have IPv6 available. Enabling IPv6 in tunnels!'
            return  0
        }
    elif test "x$(uname -s)" = "xLinux"; then
        ip -6 addr | grep -i 'scope global' >/dev/null 2>&1 && {
            echo 'Looks like you have IPv6 available. Enabling IPv6 in tunnels!'
            return  0
        }
    else
        echo 'Unsupported operating system. Unable to detect IPv6 availability.'
    fi
    return 1
}

update_seq_no() {
    echo "$1" > seqno.txt
}

create_seq_no() {
    echo "No seqno.txt... creating one!"
    update_seq_no 10
}

get_seq_no() {
    SEQNO=$(cat seqno.txt)
    NEXT=$((SEQNO+1))
    update_seq_no $NEXT
    echo "$SEQNO"
}

create_port_no() {
    echo "No portno.txt... creating one!"
    shuf -i 1025-65535 -n 1 > portno.txt
}

get_port_no() {
    cat portno.txt
}

create_psk() {
    echo "No wgpsk.key... creating one!"
    wg genpsk > wgpsk.key
}

create_hub_key() {
    echo "No wghub.key... creating one!"
    wg genkey > wghub.key
}

create_iptables_rules() {
    cat << EOF
PostUp = iptables -t mangle -A POSTROUTING -p tcp --tcp-flags SYN,RST SYN -o $EXT_NET_IF -j TCPMSS --clamp-mss-to-pmtu
PostUp = ip6tables -t mangle -A POSTROUTING -p tcp --tcp-flags SYN,RST SYN -o $EXT_NET_IF -j TCPMSS --clamp-mss-to-pmtu
PostUp = iptables -t nat -A POSTROUTING -o $EXT_NET_IF -j MASQUERADE
PostUp = ip6tables -t nat -A POSTROUTING -o $EXT_NET_IF -j MASQUERADE
PostUp = iptables -A FORWARD -i %i -j ACCEPT
PostUp = ip6tables -A FORWARD -i %i -j ACCEPT
PostUp = sysctl -q -w net.ipv4.ip_forward=1
PostUp = sysctl -q -w net.ipv6.conf.all.forwarding=1

PostDown = sysctl -q -w net.ipv4.ip_forward=0
PostDown = sysctl -q -w net.ipv6.conf.all.forwarding=0
PostDown = iptables -D FORWARD -i %i -j ACCEPT
PostDown = ip6tables -D FORWARD -i %i -j ACCEPT
PostDown = iptables -t nat -D POSTROUTING -o $EXT_NET_IF -j MASQUERADE
PostDown = ip6tables -t nat -D POSTROUTING -o $EXT_NET_IF -j MASQUERADE
PostDown = iptables -t mangle -D POSTROUTING -p tcp --tcp-flags SYN,RST SYN -o $EXT_NET_IF -j TCPMSS --clamp-mss-to-pmtu
PostDown = ip6tables -t mangle -D POSTROUTING -p tcp --tcp-flags SYN,RST SYN -o $EXT_NET_IF -j TCPMSS --clamp-mss-to-pmtu
EOF
}

create_pf_rules() {
    cat << EOF
PostUp = printf 'nat on $EXT_NET_IF from %i:network to any -> ($EXT_NET_IF)\\npass all\\n' | pfctl -f -
PostUp = pfctl -e
PostUp = sysctl net.inet.ip.forwarding=1
PostUp = sysctl net.inet6.ip6.forwarding=1

PostDown = sysctl net.inet.ip.forwarding=0
PostDown = sysctl net.inet6.ip6.forwarding=0
PostDown = pfctl -d
PostDown = printf '' | pfctl -f -
EOF
}

create_hub_conf() {
    echo "No wghub.conf... creating one!"
    cat > wghub.conf << EOF
[Interface]
Address = $INT_NET_HUB_IP$INT_NET_MASK$($NET6 && echo ", $INT_NET6_HUB_IP$INT_NET6_MASK")
ListenPort = $EXT_NET_PORT
PrivateKey = $(cat wghub.key)
SaveConfig = false

EOF

    if test "x$FW_TYPE" = "xiptables"; then
        create_iptables_rules >> wghub.conf
    elif test "x$FW_TYPE" = "xpf"; then
        create_pf_rules >> wghub.conf
    elif test "x$FW_TYPE" = "xcustom"; then
        echo '# Custom PostUp / PostDown commands from commands.txt' >> wghub.conf
        cat commands.txt >> wghub.conf
    elif test "x$FW_TYPE" = "xnone"; then
        echo '# PostUp / PostDown commands disabled with "none" set in fwtype.txt' >> wghub.conf
    fi

    echo "Wireguard hub address is $EXT_NET_IP:$EXT_NET_PORT on $EXT_NET_IF."
    echo "Note: customize [Interface] section of wghub.conf if required!"
}

create_new_client_conf() {
    SEQNO="$1"
    CONF_NAME="$2"

    echo "No wgclient_$CONF_NAME.conf... creating one!"
    cat > "wgclient_$CONF_NAME.conf" << EOF
# $SEQNO: $CONF_NAME > wgclient_$CONF_NAME.conf
[Interface]
Address = $INT_NET_PEER$SEQNO$INT_NET_MASK$($NET6 && echo ", $INT_NET6_PEER$SEQNO$INT_NET6_MASK")
DNS = $INT_NET_DNS$($NET6 && echo ", $INT_NET6_DNS")
PrivateKey = $(wg genkey | tee "wgclient_$CONF_NAME.key")

[Peer]
PublicKey = $(wg pubkey < wghub.key)
PresharedKey = $(cat wgpsk.key)
AllowedIPs = 0.0.0.0/0, ::/0
Endpoint = $EXT_NET_IP:$EXT_NET_PORT
PersistentKeepalive = 25
EOF
}

add_client_to_hub_conf() {
    SEQNO="$1"
    CONF_NAME="$2"

    printf "Updating wghub.conf..."
    cat >> wghub.conf << EOF

# $SEQNO: $CONF_NAME > wgclient_$CONF_NAME.conf
[Peer]
PublicKey = $(wg pubkey < "wgclient_$CONF_NAME.key")
PresharedKey = $(cat wgpsk.key)
AllowedIPs = $INT_NET_PEER$SEQNO$INT_NET_PEER_MASK$($NET6 && echo ", $INT_NET6_PEER$1$INT_NET6_PEER_MASK")
EOF
    echo " done!"
cat << EOF

Important: Deploy updated wghub.conf configuration to wireguard with wg-quick:
  sudo wg-quick down ./wghub.conf # if already configured
  sudo wg-quick up ./wghub.conf
  sudo wg show # to check status
EOF
}

print_client_conf() {
    echo "-----BEGIN CONFIG-----"
    cat "wgclient_$1.conf"
    echo "-----END CONFIG-----"
}

print_client_qrcode() {
    qrencode -t ansiutf8 < "wgclient_$1.conf"
    echo "Scan QR code with your phone or use \"wgclient_$1.conf\" file."
}

remove_temporary_client_key_file() {
    rm -f "wgclient_$1.key"
}

check_conf_name_is_available() {
    FILENAME="wgclient_$1.conf"
    if test -e "$FILENAME"; then
        printf '\nUnable to store configuration with chosen name: "%s" already exists.\n' "$FILENAME"
        return 1
    fi
    return 0
}

print_conf_name_help() {
    cat << EOF

Note: passing argument to script creates client configuration with supplied
      name to help remembering which config was for which device. If you
      didn't pass any argument you can still rename created file manually
      with command:
  mv -vi wgclient_$1.conf wgclient_name.conf

EOF
}

create_new_client() {
    SEQNO="$1"
    CONF_NAME="$2"

    create_new_client_conf "$SEQNO" "$CONF_NAME"
    if qrencode -V >/dev/null 2>&1; then
        print_client_qrcode "$CONF_NAME"
    else
        print_client_conf "$CONF_NAME"
    fi
    add_client_to_hub_conf "$SEQNO" "$CONF_NAME"
    remove_temporary_client_key_file "$CONF_NAME"
}

main() {
    umask 077

    CONF_NAME="$1"

    test -f extnetif.txt || create_ext_net_if
    EXT_NET_IF="$(get_ext_net_if)"
    test -f extnetip.txt || create_ext_net_ip "$EXT_NET_IF"
    EXT_NET_IP="$(get_ext_net_ip)"
    INT_NET_HUB_IP="10.127.0.1"

    INT_NET_MASK="/24"
    INT_NET_DNS="1.1.1.1"
    INT_NET_PEER="10.127.0."
    INT_NET_PEER_MASK="/32"

    test -f fwtype.txt || create_fw_type
    FW_TYPE="$(get_fw_type)"

    NET6=false
    check_if_ipv6_is_available "$EXT_NET_IF" && {
        NET6=true
        INT_NET6_HUB_IP="fdfc:2965:0503:e2ae::1"
        INT_NET6_MASK="/64"
        INT_NET6_DNS="2606:4700:4700::1111"
        INT_NET6_PEER="fdfc:2965:0503:e2ae::"
        INT_NET6_PEER_MASK="/128"
    }

    check_if_wg_is_installed
    test -f seqno.txt  || create_seq_no
    SEQNO="$(get_seq_no)"
    test -f portno.txt || create_port_no
    EXT_NET_PORT="$(get_port_no)"
    test -f wgpsk.key  || create_psk
    test -f wghub.key  || create_hub_key
    test -f wghub.conf || create_hub_conf

    if test -z "$CONF_NAME"; then
        CONF_NAME="$SEQNO"
        print_conf_name_help "$SEQNO"
    fi

    if check_conf_name_is_available "$CONF_NAME"; then
        create_new_client "$SEQNO" "$CONF_NAME"
    fi
}

main "$1"
